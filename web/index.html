<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AI-Manuals demo</title>
  <!-- If API is on a different origin, set this meta. Otherwise omit it. -->
  <!-- <meta name="api-base" content="https://your-api.onrender.com"> -->
  <!-- If you MUST use a short-lived public token, render it server-side under this name -->
  <!-- <meta name="api-token" content="scoped-short-lived-token"> -->
  <style>
    body {font-family:sans-serif;max-width:680px;margin:auto;padding:20px}
    #answer{white-space:pre-wrap;border:1px solid #ccc;padding:12px;margin-top:12px}
    .fb {font-size:20px;margin:0 6px;cursor:pointer}
    .hide{display:none}
    #status{margin-top:10px;font-size:14px;color:#555}
    #status.error{color:#c00}
    .muted{color:#777}
  </style>
</head>
<body>
  <h2>Manual helper</h2>

  <h4>Upload a PDF</h4>
  <input type="file" id="pdf" accept="application/pdf" />
  <button id="uploadBtn">Upload</button>
  <div id="status"></div>

  <h4>Ask a question</h4>
  <input id="q" size="60" placeholder="Type your question‚Ä¶" disabled />
  <button id="askBtn" disabled>Ask</button><br><br>

  <div id="answer"></div>
  <div id="fb" class="hide" aria-label="feedback">
    <span class="fb" id="fb-up"  title="Good">üëç</span>
    <span class="fb" id="fb-down" title="Bad">üëé</span>
  </div>

<script>
// ---------- config / auth ----------
function apiBase() {
  const meta = document.querySelector('meta[name="api-base"]');
  return meta?.content?.trim() || ''; // empty => same-origin
}
function joinUrl(base, path){ if(!base) return path; return base.replace(/\/+$/,'') + path; }
function headers(extra = {}) {
  const token = document.querySelector('meta[name="api-token"]')?.content || "";
  return token ? { "X-API-Key": token, ...extra } : { ...extra };
}
async function fetchJSON(path, opts={}) {
  const res = await fetch(joinUrl(apiBase(), path), {
    credentials: 'include',     // ‚úÖ send cookies for session auth
    headers: headers(opts.headers || {}),
    method: opts.method || 'GET',
    body: opts.body,
  });
  if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
  const text = await res.text();            // tolerate 204/empty bodies
  if (!text) return null;
  try { return JSON.parse(text); } catch { return null; }
}

// ---------- elements ----------
const pdf       = document.getElementById('pdf');
const uploadBtn = document.getElementById('uploadBtn');
const q         = document.getElementById('q');
const askBtn    = document.getElementById('askBtn');
const statusEl  = document.getElementById('status');
const answerEl  = document.getElementById('answer');
const fbDiv     = document.getElementById('fb');
const fbUp      = document.getElementById('fb-up');
const fbDown    = document.getElementById('fb-down');

// ---------- state ----------
let DOC_ID = "";
let USER_DOC_TYPE = "software"; // default
let pollTimer, uploading = false;
let lastQuestion = "";
let lastAnswer = "";
let lastChunks  = [];

// ---------- helpers ----------
function setStatus(msg, isError=false){
  statusEl.textContent = msg || "";
  statusEl.classList.toggle('error', !!isError);
}
function looksPdf(file){
  if (!file) return false;
  if (file.type === "application/pdf") return true;
  // Safari fallback
  return /\.pdf$/i.test(file.name || "");
}

// ---------- upload flow ----------
uploadBtn.addEventListener('click', async () => {
  if (uploading) return;

  const file = pdf.files?.[0];
  if (!looksPdf(file)) { alert("Please choose a PDF file."); return; }

  uploading = true;
  setStatus("Uploading‚Ä¶");
  pdf.disabled = true;
  uploadBtn.disabled = true;

  const fd = new FormData();
  fd.append("file", file);

  try {
    const js = await fetchJSON("/upload", { method: "POST", body: fd });
    if (!js || !js.doc_id) throw new Error("No doc_id returned.");
    DOC_ID = js.doc_id;

    showMetaForm();

    if (js.status === "duplicate") {
      setStatus("‚úÖ Manual already uploaded ‚Äî ready to ask.");
      q.disabled = false; askBtn.disabled = false; uploading = false;
      return;
    }

    setStatus("Processing‚Ä¶ starting embedding.");
    pollTimer = setInterval(checkReady, 2000);
  } catch (err) {
    console.error(err);
    setStatus(`‚ùå Upload failed: ${err.message}`, true);
    uploading = false;
    pdf.disabled = false;
    uploadBtn.disabled = false;
  }
});

async function checkReady() {
  if (!DOC_ID) return;
  try {
    const job = await fetchJSON(`/ingest/status?doc_id=${encodeURIComponent(DOC_ID)}`);
    const done = Number(job?.done || 0), total = Number(job?.total || 0);
    setStatus(`Embedded ${done}/${total} chunks‚Ä¶`);
    if (job?.ready) {
      clearInterval(pollTimer);
      uploading = false;
      setStatus("‚úÖ Ready ‚Äì ask away.");
      q.disabled = false;
      askBtn.disabled = false;
    }
  } catch (e) {
    console.error(e);
    clearInterval(pollTimer);
    uploading = false;
    setStatus(`‚ùå Status check failed: ${e.message}`, true);
    pdf.disabled = false;
    uploadBtn.disabled = false;
  }
}

// ---------- metadata (doc type + notes) ----------
function showMetaForm() {
  if (document.getElementById("metaForm")) return;

  const wrap = document.createElement('div');
  wrap.id = "metaForm";
  wrap.innerHTML = `
    <hr><b>What type of manual?</b><br>
    <label><input type="radio" name="dt" value="software" checked> Software</label>
    <label><input type="radio" name="dt" value="hardware"> Physical product</label>
    <label><input type="radio" name="dt" value="service"> Service</label><br>
    Notes: <input id="notes" size="40" placeholder="e.g. CNC mill">
    <button id="saveMeta">Save</button> <span id="metaStatus" class="muted"></span>
  `;
  statusEl.insertAdjacentElement("afterend", wrap);

  wrap.querySelectorAll('input[name="dt"]').forEach(r =>
    r.addEventListener('change', () => { USER_DOC_TYPE = r.value; })
  );
  document.getElementById("saveMeta").addEventListener('click', saveMeta);
}

async function saveMeta() {
  if (!DOC_ID) { alert("No doc ID yet ‚Äî try reloading."); return; }
  const notes = document.getElementById("notes")?.value || "";

  const fd = new FormData();
  fd.append("doc_id", DOC_ID);
  fd.append("doc_type", USER_DOC_TYPE);
  fd.append("notes", notes);

  try {
    await fetch(joinUrl(apiBase(), "/upload/metadata"), {
      method: "POST",
      credentials: 'include',
      headers: headers(),
      body: fd
    });
    document.getElementById("metaStatus").textContent = "‚úîÔ∏è saved";
  } catch (e) {
    console.error(e);
    document.getElementById("metaStatus").textContent = "‚ùå save failed";
  }
}

// ---------- ask ----------
askBtn.addEventListener('click', ask);
q.addEventListener('keydown', (e) => { if(e.key === 'Enter' && !askBtn.disabled) ask(); });

async function ask() {
  if (!DOC_ID || !q.value.trim()) return;
  askBtn.disabled = true;
  answerEl.textContent = "Thinking‚Ä¶";
  fbDiv.classList.add("hide");

  const fd = new FormData();
  fd.append("question", q.value);
  fd.append("doc_type", USER_DOC_TYPE);
  fd.append("doc_id", DOC_ID);

  try {
    const js = await fetchJSON("/chat", { method: "POST", body: fd });
    answerEl.textContent = js?.answer || "(no answer)";
    lastQuestion = q.value;
    lastAnswer   = js?.answer || "";
    lastChunks   = Array.isArray(js?.chunks_used) ? js.chunks_used : [];
    fbDiv.classList.remove("hide");
  } catch (e) {
    console.error(e);
    answerEl.textContent = `‚ùå Error: ${e.message}`;
  } finally {
    askBtn.disabled = false;
  }
}

// ---------- feedback ----------
async function sendFeedback(good) {
  if (!DOC_ID) return;
  const body = {
    doc_id:   DOC_ID,
    question: lastQuestion,
    answer:   lastAnswer,
    chunks:   lastChunks,     // ‚úÖ send as array
    good:     good > 0
  };
  try {
    const res = await fetch(joinUrl(apiBase(), "/feedback"), {
      method: "POST",
      credentials: 'include',
      headers: headers({ "Content-Type": "application/json" }),
      body: JSON.stringify(body),
    });
    // tolerate 204
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
  } catch (e) {
    console.error("Feedback failed:", e);
  } finally {
    fbDiv.classList.add("hide");
  }
}
fbUp.addEventListener('click', () => sendFeedback(1));
fbDown.addEventListener('click', () => sendFeedback(-1));
</script>

<hr>
<h4>QA Health (last 30 days)</h4>
<canvas id="qaChart" height="120"></canvas>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
<script>
async function drawChart() {
  try {
    const data = await fetch(joinUrl(apiBase(), "/metrics"), {
      credentials: 'include',
      headers: headers()
    }).then(async res => {
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const text = await res.text();
      return text ? JSON.parse(text) : { records: [] };
    });

    const rows = Array.isArray(data?.records) ? data.records : [];
    if (!rows.length) return;

    const labels = rows.map(d => (d?.timestamp || '').slice(5));
    const chunks = rows.map(d => Number(d?.count || 0));
    const conf   = rows.map(d => Number(d?.avg_conf || 0));

    new Chart(document.getElementById("qaChart"), {
      type: "bar",
      data: {
        labels,
        datasets: [
          { label: "avg chunks", data: chunks },
          { label: "avg conf",   data: conf, type: "line", yAxisID: "y1" }
        ]
      },
      options: {
        animation: false,
        scales: {
          y:  { beginAtZero: true },
          y1: { position: "right", min: 0, max: 1 }
        }
      }
    });
  } catch (e) {
    console.error("Metrics load failed:", e);
  }
}
drawChart();
</script>
</body>
</html>
